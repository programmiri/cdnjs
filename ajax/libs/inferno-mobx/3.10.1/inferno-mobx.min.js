!(function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("inferno-component"),require("inferno-create-class"),require("hoist-non-inferno-statics"),require("inferno"),require("mobx")):"function"==typeof define&&define.amd?define(["exports","inferno-component","inferno-create-class","hoist-non-inferno-statics","inferno","mobx"],t):t((e.Inferno=e.Inferno||{},e.Inferno.Mobx={}),e.Inferno.Component,e.Inferno.createClass,e.hoistStatics,e.Inferno,e.mobx)})(this,(function(e,t,n,r,o,i){"use strict";function s(e){throw e||(e=v),new Error("Inferno Error: "+e)}function a(e){console.warn(e)}function c(){this.listeners=[]}function p(e,t,i){var s="inject-"+(t.displayName||t.name||t.constructor&&t.constructor.name||"Unknown");i&&(s+="-with-"+i);var a=n({displayName:s,render:function(){var n=this,r={};for(var i in n.props)n.props.hasOwnProperty(i)&&(r[i]=n.props[i]);var s=e(this.context.mobxStores||{},r,this.context)||{};for(var a in s)r[a]=s[a];return r.ref=function(e){n.wrappedComponent=e},o.createVNode(16,t,null,null,r)}});return a.contextTypes={mobxStores:function(){}},r(a,t),a}function u(e){var t=arguments;if("function"!=typeof e){for(var n=[],r=0,o=arguments.length;r<o;r++)n[r]=t[r];e=b(n)}return function(t){return p(e,t)}}function f(e){var t=e._vNode.dom;t&&w&&w.set(t,e),S.emit({component:e,event:"render",node:t,renderTime:e.__$mobRenderEnd-e.__$mobRenderStart,totalTime:Date.now()-e.__$mobRenderStart})}function d(){"undefined"==typeof WeakMap&&s("[inferno-mobx] tracking components is not supported in this browser."),g||(g=!0)}function l(e){_=e}function m(e,t){var n=this;if(_&&a("[inferno-mobx] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side."),this.state!==t)return!0;var r=Object.keys(this.props);if(r.length!==Object.keys(e).length)return!0;for(var o=r.length-1;o>=0;o--){var s=r[o],c=e[s];if(c!==n.props[s])return!0;if(c&&"object"==typeof c&&!i.isObservable(c))return!0}return!1}function h(e){var n=e.prototype||e,r=n.componentDidMount,o=n.componentWillMount,s=n.componentWillUnmount;return n.componentWillMount=function(){var e=this;if(!0!==_){o&&o.call(this);var n,r=!1,s=this.displayName||this.name||this.constructor&&(this.constructor.displayName||this.constructor.name)||"<component>",a=this.render.bind(this),c=function(t,o){r=!1;var s;return n.track((function(){g&&(e.__$mobRenderStart=Date.now()),s=i.extras.allowStateChanges(!1,a.bind(e,t,o)),g&&(e.__$mobRenderEnd=Date.now())})),s};this.render=function(o,a){return n=new i.Reaction(s+".render()",function(){if(!r&&(r=!0,!0!==e.__$mobxIsUnmounted)){var o=!0;try{t.prototype.forceUpdate.call(e),o=!1}finally{o&&n.dispose()}}}),c.$mobx=n,e.render=c,c(o,a)}}},n.componentDidMount=function(){g&&f(this),r&&r.call(this)},n.componentWillUnmount=function(){if(!0!==_&&(s&&s.call(this),this.render.$mobx&&this.render.$mobx.dispose(),this.__$mobxIsUnmounted=!0,g)){var e=this._vNode.dom;e&&w&&w.delete(e),S.emit({component:this,event:"destroy",node:e})}},n.shouldComponentUpdate||(n.shouldComponentUpdate=m),e}function y(e,r){if("string"==typeof e&&s("Store names should be provided as array"),Array.isArray(e))return r?u.apply(null,e)(y(r)):function(t){return y(e,t)};var o=e;return"function"!=typeof o||o.prototype&&o.prototype.render||o.isReactClass||t.isPrototypeOf(o)?(o||s('Please pass a valid component to "connect"'),o.isMobXReactObserver=!0,h(o)):y(n({contextTypes:o.contextTypes,displayName:o.displayName||o.name,getDefaultProps:function(){return o.defaultProps},propTypes:o.propTypes,render:function(){return o.call(this,this.props,this.context)}}))}t=t&&t.hasOwnProperty("default")?t.default:t,n=n&&n.hasOwnProperty("default")?n.default:n,r=r&&r.hasOwnProperty("default")?r.default:r;var v="a runtime error occured! Use Inferno in development environment to find the error.";c.prototype.addListener=function(e){this.listeners.push(e)},c.prototype.trigger=function(){for(var e,t=this.listeners;e=t.shift();)e()};var b=function(e){return function(t,n){return e.forEach((function(e){if(!(e in n)){if(!(e in t))throw new Error("MobX observer: Store '"+e+"' is not available! Make sure it is provided by some Provider");n[e]=t[e]}})),n}},x=function(){this.listeners=[]};x.prototype.on=function(e){var t=this;return this.listeners.push(e),function(){var n=t.listeners.indexOf(e);-1!==n&&t.listeners.splice(n,1)}},x.prototype.emit=function(e){for(var t=this.listeners,n=0,r=t.length;n<r;n++)t[n](e)},x.prototype.getTotalListeners=function(){return this.listeners.length},x.prototype.clearListeners=function(){this.listeners=[]};var g=!1,_=!1,w=new WeakMap,S=new x,R={children:!0,key:!0,ref:!0},C=(function(e){function t(t,n){e.call(this,t,n),this.contextTypes={mobxStores:function(){}},this.childContextTypes={mobxStores:function(){}},this.store=t.store}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.render=function(){return this.props.children},t.prototype.getChildContext=function(){var e=this,t={},n=this.context.mobxStores;if(n)for(var r in n)t[r]=n[r];for(var o in e.props)R[o]||"suppressChangedStoreWarning"===o||(t[o]=e.props[o]);return{mobxStores:t}},t})(t),P={EventEmitter:x,Provider:C,componentByNodeRegistery:w,connect:y,inject:u,observer:y,renderReporter:S,trackComponents:d,useStaticRendering:l};e.default=P,e.EventEmitter=x,e.Provider=C,e.componentByNodeRegistery=w,e.observer=y,e.connect=y,e.inject=u,e.renderReporter=S,e.trackComponents=d,e.useStaticRendering=l,Object.defineProperty(e,"__esModule",{value:!0})}));
